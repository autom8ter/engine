# Engine

![](https://www.google.com/url?sa=i&source=images&cd=&cad=rja&uact=8&ved=2ahUKEwi828rtrpThAhVDyYMKHRTpDz8QjRx6BAgBEAU&url=https%3A%2F%2Fwww.vectorstock.com%2Froyalty-free-vector%2Fmotor-engine-vector-5881&psig=AOvVaw30k6gyAjR8wy-y1i5reNzc&ust=1553296573608606)
    
A Pluggable gRPC Microservice Framework
               
`go get github.com/autom8ter/engine`

`go get github.com/autom8ter/engine/enginectl`

Contributers: Coleman Word

License: MIT

## Overview
Engine is a pluggable framework for grpc services

- Engine serves go/plugins that. 
- Plugins must export a type that implements the driver.Plugin interface: RegisterWithServer(s *grpc.Server)
- Exported plugins must be named Plugin

## Features

### Engine Library:
- [x] Load grpc services from go/plugins at runtime that satisfy driver.Plugin
- [x] Load go/plugins from paths set in config file
- [x] Support for loading driver.Plugins directly(no go/plugins)
- [x] Support for custom gRPC Server options
- [x] Support for custom and chained Unary Interceptors
- [x] Support for custom and chained Stream Interceptors
- [ ] Load go/plugins from paths set in environmental variables
- [ ] Load go/plugins directly from AWS S3
- [ ] Load go/plugins directly from GCP storage
- [ ] Load go/plugins directly from Github
- [ ] Load go/plugins directly from a Kubernetes Volume

### Enginectl (cli)
`go get github.com/autom8ter/engine/enginectl`
- [x] Load and serve grpc services from go/plugins at runtime that satisfy driver.Plugin
- [ ] Codegen: Makefile
- [ ] Codegen: Basic config file
- [ ] Codegen: Basic Protobuf file
- [ ] Codegen: Helm Chart
- [ ] Codegen: Dockerfile
- [ ] Codegen: Kubernetes Deployment
- [ ] Codegen: Google Endpoints Deployment
- [ ] Codegen: AWS API Gateway Deployment

## Plugins

```go
// Plugin is an interface for representing gRPC server implementations.
type Plugin interface {
	RegisterWithServer(*grpc.Server)
}

//PluginFunc implements the Plugin interface.
type PluginFunc func(*grpc.Server)

func (p PluginFunc) RegisterWithServer(s *grpc.Server) {
	p(s)
}

```
### Example Implementation

```go
//Plugin is an exported driver.Plugin for use with go/plugin
var Plugin  Example

//Embeded driver.PluginFunc satisfies driver.Plugin interface
type Example struct {
	driver.PluginFunc
}

//Create a driver.PluginFunc from code generated by protoc
func NewExample() *Example {
	e := &Example{}
	e.PluginFunc = func(s *grpc.Server) {
		examplepb.RegisterEchoServiceServer(s, e)
	}
	return e
}

```

### Generating a Go/Plugin

ref: https://golang.org/pkg/plugin/

A plugin is a Go main package with exported functions and variables that has been built with:

    go build -buildmode=plugin

When a plugin is first opened, the init functions of all packages not already part of the program are called. The main 
function is not run. A plugin is only initialized once, and cannot be closed.

**Plugins are only supported on Linux and macOS**

- Ensure that you place the path to all generated plugins in your config file
- Engine will scan each file in your config for a variable named Plugin 
that satisfies the driver.Plugin interface, and then serve it as a grpc service on the network and 
address present in your config.

Example:

    go build -buildmode=plugin -o ./plugins/$TARGETOUTPUT.plugin $TARGETGOFILE.go

then add plugins/$TARGETOUTPUT.plugin to your config file (see below for example config)

### Not Using go/plugin?

No problem!

Use the following config option:

```go
// WithServers returns an Option that sets gRPC service server implementation(s).
func WithGoPlugins(svrs ...driver.Plugin) Option {
	return func(c *Config) {
		c.Plugins = append(c.Plugins, svrs...)
		if len(c.Plugins) == 0 {
			grpclog.Fatal(errors.New("zero valid plugins registered"))
		}
	}
}
```

Create an Engine instance:

```go
engine.New().With(
		config.WithGRPCLogger(),
		config.WithGoPlugins(ExampleGolangPlugin)
	)
```

See config/options.go for all options that may be passed when creating an 
engine instance

Note: If paths to plugins are available in your config, they will be served
in addition to your non.plugin driver.Plugin's.


## Configuration

- Config files must be either config.json or config.yaml in your current working directory

Variables:
- address: address to listen on
- network: tcp/unix
- paths: paths to generated plugin files to load

example:
```json
{
  "address": ":3000",
  "network": "tcp",
  "paths": [
    "plugins/example.plugin"
  ]
}

```

## Grpc Middlewares

### Key Functions:
    type StreamServerInterceptor func(srv interface{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error
    type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)

### Example(recovery): 
```go
// UnaryServerInterceptor returns a new unary server interceptor for panic recovery.
func UnaryServerInterceptor(opts ...Option) grpc.UnaryServerInterceptor {
	o := evaluateOptions(opts)
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (_ interface{}, err error) {
		defer func() {
			if r := recover(); r != nil {
				err = recoverFrom(ctx, r, o.recoveryHandlerFunc)
			}
		}()

		return handler(ctx, req)
	}
}

// StreamServerInterceptor returns a new streaming server interceptor for panic recovery.
func StreamServerInterceptor(opts ...Option) grpc.StreamServerInterceptor {
	o := evaluateOptions(opts)
	return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) (err error) {
		defer func() {
			if r := recover(); r != nil {
				err = recoverFrom(stream.Context(), r, o.recoveryHandlerFunc)
			}
		}()

		return handler(srv, stream)
	}
}
```
Please see [go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware) for a list of useful
Unary and Streaming Interceptors

## EngineCtl

EngineCtl is a very basic implementation of the Engine library that allows
users to use flags to override a config file. It requires zero coding to 
use most of the functionality of the engine library since users only need to 
provide paths to plugins to create a fully customizable grpc microservice.

**It is particularly useful in containers:**

-> download enginectl -> copy plugins to container->copy config file to container-> enginectl init
```text
- RUN go get github.com/autom8ter/engine/enginectl
- COPY plugins/example.plugin /plugins
- COPY config.json .
- ENTRYPOINT [ "enginectl", "init"] 
```

Assign individual developers to develop specific plugins and then 
just add them as a plugin config path. Plugin development is completely
independent of the runtime NICE.